/*
  fix32_fft.h - single-file-header fixed-point in-place Fast Fourier Transform
  geared for embedded, and/or power-reduced 32-bit integer system.


  Copyright (c) 2006 Dimitrios P. Bouras dbouras@ieee.org
  Copyright (c) 2025 cnlohr <lohr85@gmail.com>

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to
  deal in the Software without restriction, including without limitation the
  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
  sell copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
  IN THE SOFTWARE.


  This comes from the fix_fft.c lineage, but is basically a rewrite.  You can
  see a copy of the original here: https://gist.github.com/Tomwi/3842231 

  The original (unlicensed version is)
     Written by:  Tom Roberts  11/8/89
     Made portable:  Malcolm Slaney 12/15/94 malcolm@interval.com
     Enhanced:  Dimitrios P. Bouras  14 Jun 2006 dbouras@ieee.org

  This version has 32-bit and other changes below.

  Dimitrios P. Bouras is expressly licensing their changes under the MIT
  license.

  I greatly admired their interface and approach, but I needed it in more bits
  and I needed it to do much larger FFTs.

// Perform a real-only FFT
int fix32_fftr( int32_t fr[], int m, int inverse );

// Perform a full FFT.
int fix32_fft( int32_t fr[], int32_t fi[], int m, int inverse );

// Multiply 2 32-bit numbers
inline int32_t FIX_MPY(int32_t a, int32_t b)

// To keep the FFT in range, you will need to decimate the values.
int fix32_decimate( int32_t * fr, int32_t * fi, int m, int decimate ); 

Options:

//  Do precise rounding in multiply. This prevents a tendency towards zero. For
//  16-bit math (or smaller numbers) this matters a lot.  But if you scale your
//  inputs appropraitely, it does not really matter.
#define FIX32_FFT_PRECISEROUNDING 1

// Set this when including this file to include the body of the functions.
#define FIX32_FFT_IMPLEMENTATION

  Notable changes from original version:
   * Original file was not licensed.

   * Original lineage was 16-bits - we expand this to 32-bits because most
     modern 32-bit processors have instructions like "mulh" which allow very
     fast 32x32 multiplies.  Additionally, 16 bits were insufficient for my
     purposes

   * Originally maxed out at 1024-wide FFTs. This implementation supports 
     up to 16777216-wide FFTs

   * Original code used a LUT for the sin/cos lookup.  This version uses a
     rotates between sin/cos valuse in the much smaller lookup.

   * Original code used shifting to prevent overflow.  Moving to 32-bits 
     obviates the need for the shifting logic.  We instead "shrink" on even
     phases and expand on odd phases.  By going back and forth we can much
     more effectively use the 

   * Original code used "precise" rounding to dither in the loss of the 
     lsb on multiplies. You can turn this off

  They also note:
     fix_fftr() - forward/inverse FFT on array of real numbers.
     Real FFT/iFFT using half-size complex FFT by distributing
     even/odd samples into real/imaginary arrays respectively.
     In order to save data space (i.e. to avoid two arrays, one
     for real, one for imaginary samples), we proceed in the
     following two steps: a) samples are rearranged in the real
     array so that all even samples are in places 0-(N/2-1) and
     all imaginary samples in places (N/2)-(N-1), and b) fix_fft
     is called with fr and fi pointing to index 0 and index N/2
     respectively in the original array. The above guarantees
     that fix_fft "sees" consecutive real samples as alternating
     real and imaginary samples in the complex array.

     fix_fft() - perform forward/inverse fast Fourier transform.
     fr[n],fi[n] are real and imaginary arrays, both INPUT AND
     RESULT (in-place FFT), with 0 <= n < 2**m; set inverse to
     0 for forward transform (FFT), or 1 for iFFT.
*/

#ifndef FIX32_FFT_H
#define FIX32_FFT_H

#include <stdint.h>

int fix32_fftr( int32_t fr[], int m, int inverse );

int fix32_fft( int32_t fr[], int32_t fi[], int m, int inverse );

void fix32_shift( int32_t * fr, int32_t * fi, int m, int shift );

#ifdef FIX32_FFT_IMPLEMENTATION

// These constants and the tables below are generated by "genrotations.c." You
// can decide the trade-off with size and precision by adjusting SINESIZEL2.
// Larger numbers will make the sine table bigger, and thus make it more
// precise.  But also, there are performance tradeoffs, for instance if memory
// accesses are slow, then you are better off making your table smaller.
//
// In general past sizel2 = 7, you get **massively** diminishing results where
// using a much larger table will sometimes have bit-for-bit identical outputs

#define SINESIZEL2 7
#define SINESIZE (1<<SINESIZEL2)
#define SINEMASK (SINESIZE-1)
#define LOG2_N_WAVE 24
#define N_WAVE 16777216

int32_t sinetable_base[SINESIZE + SINESIZE/4] = {
	          0,  105372028,  210490206,  315101294,  418953276,  521795963,
	  623381597,  723465451,  821806413,  918167571, 1012316784, 1104027236,
	 1193077990, 1279254515, 1362349203, 1442161873, 1518500249, 1591180425,
	 1660027308, 1724875039, 1785567395, 1841958164, 1893911493, 1941302224,
	 1984016188, 2021950483, 2055013722, 2083126253, 2106220351, 2124240379,
	 2137142926, 2144896909, 2147483647, 2144896909, 2137142926, 2124240379,
	 2106220351, 2083126253, 2055013722, 2021950483, 1984016188, 1941302224,
	 1893911493, 1841958164, 1785567395, 1724875039, 1660027308, 1591180425,
	 1518500249, 1442161874, 1362349204, 1279254515, 1193077990, 1104027236,
	 1012316784,  918167571,  821806413,  723465451,  623381598,  521795963,
	  418953276,  315101295,  210490206,  105372028,          0, -105372027,
	 -210490205, -315101293, -418953275, -521795962, -623381596, -723465450,
	 -821806412, -918167570,-1012316782,-1104027235,-1193077989,-1279254514,
	-1362349202,-1442161872,-1518500248,-1591180424,-1660027306,-1724875038,
	-1785567394,-1841958162,-1893911492,-1941302223,-1984016187,-2021950482,
	-2055013721,-2083126252,-2106220350,-2124240378,-2137142925,-2144896908,
	-2147483646,-2144896908,-2137142925,-2124240378,-2106220350,-2083126252,
	-2055013721,-2021950482,-1984016187,-1941302223,-1893911492,-1841958163,
	-1785567395,-1724875038,-1660027307,-1591180424,-1518500249,-1442161873,
	-1362349203,-1279254514,-1193077989,-1104027235,-1012316783, -918167571,
	 -821806412, -723465450, -623381597, -521795962, -418953276, -315101294,
	 -210490205, -105372028,          0,  105372028,  210490206,  315101294,
	  418953276,  521795962,  623381597,  723465451,  821806413,  918167571,
	 1012316783, 1104027236, 1193077990, 1279254515, 1362349203, 1442161873,
	 1518500249, 1591180425, 1660027307, 1724875039, 1785567395, 1841958163,
	 1893911493, 1941302224, 1984016188, 2021950483, 2055013722, 2083126253,
	 2106220351, 2124240379, 2137142926, 2144896909,};

uint32_t rotationsets[(LOG2_N_WAVE-SINESIZEL2)*2] = {
	 4293673732,   105403774,
	 4294643893,    52705856,
	 4294886444,    26353424,
	 4294947083,    13176774,
	 4294962243,     6588395,
	 4294966033,     3294199,
	 4294966978,     1647100,
	 4294967215,      823550,
	 4294967273,      411775,
	 4294967289,      205888,
	 4294967291,      102944,
	 4294967293,       51472,
	 4294967293,       25736,
	 4294967293,       12868,
	 4294967293,        6434,
	 4294967293,        3217,
	 4294967293,        1609,
};


static inline int32_t FIX_MPY(int32_t a, int32_t b)
{
#if FIX32_FFT_PRECISEROUNDING
	int32_t mulval = ((int64_t)a * (int64_t)b) >> 30;
	int32_t tmp = mulval & 0x01;  // Grab LSB 
	return (mulval >> 1) + tmp; // And add it back in
#else
	// Default behavior is to not do precise rounding, so we go brrrr. This
	// turns into a single mulh instruction on RISC-V or a smull on ARM.
	return ((int64_t)a * (int64_t)b) >> 32;
#endif
}

#define FIX32FFT_SWAP( a, b ) { int32_t tmp = a; a = b; b = tmp; }

int fix32_fft( int32_t fr[], int32_t fi[], int M, int inverse )
{
	int i, j, l;

	// Compute N from _m_
	int N = 1 << M;

	// Make sure we aren't too big.
	if( M > LOG2_N_WAVE )
		return -1;

	// FFTs want the input data fields to be fractally flipped. This canbe 
	// cleverly accomplished by computing the flipped locations by flipping
	// the sequence of bits inside a word. 
	for ( l = 1; l < N; ++l )
	{
#if LOG2_N_WAVE <= 16
		// Hacker's delight addendum (not in first edition) "rev11a" bit
		// reversal. Only works for up to 16 bits.
		uint32_t tmp;
		uint32_t mr = l | ((l & 0x000000FF) << 16);
		tmp = mr & 0x0F0F0F0F; mr = (tmp <<  8) | (tmp ^ mr);
		tmp = mr & 0x33333333; mr = (tmp <<  4) | (tmp ^ mr);
		tmp = mr & 0x55555555; mr = (tmp <<  2) | (tmp ^ mr);
		mr = mr >> (31-M);
#else
		// Hacker's delight for bit reversal, "rev1" - basic bit reversal
		uint32_t tmp = (l & 0x55555555) << 1 | (l & 0xAAAAAAAA) >>  1;
		tmp = (tmp & 0x33333333) <<  2 | (tmp & 0xCCCCCCCC) >>  2;
		tmp = (tmp & 0x0F0F0F0F) <<  4 | (tmp & 0xF0F0F0F0) >>  4;
		tmp = (tmp & 0x00FF00FF) <<  8 | (tmp & 0xFF00FF00) >>  8;
		tmp = (tmp & 0x0000FFFF) << 16 | (tmp & 0xFFFF0000) >> 16;
		uint32_t mr = tmp >> (32-M);
#endif

		// Make sure when we swap, we don't swap them back.
		if (mr <= l) continue;

		FIX32FFT_SWAP( fr[l], fr[mr] );
		FIX32FFT_SWAP( fi[l], fi[mr] );
	}

	int inverseoctave = 0;
	int istep;

	for( l = 1; l < N; l = istep, inverseoctave++ )
	{
		istep = l << 1;

		int sinecheck = 1;
		int sinelookuploc = 0;

		// Will get set in first iteration, but gcc complains anyway :( if
		// we don't initialize them here.
		int wr = 0, wi = 0;

		// Tricky, br must be uint32_t because it uses the MSBit.
		// The code involving br will not run unless M > SINESIZEL2
		uint32_t br = 0;
		int32_t bi = 0;
		if( inverseoctave >= SINESIZEL2 )
		{
			br = rotationsets[(inverseoctave-SINESIZEL2)*2+0];
			bi = rotationsets[(inverseoctave-SINESIZEL2)*2+1];

			if (inverse)  // If inverse, make phasor go backwards.
				bi = -bi;
		}

		int m;
		for( m = 0; m < l; ++m )
		{
			if( --sinecheck == 0 )
			{
				// Any chance we get to use the sine table, we should take it.
				// This is because our complex rotations accumulate error.
				// By using the sinetable in these changes, we can keep the
				// error especailly low.
				wr = sinetable_base[sinelookuploc+SINESIZE/4];
				wi = sinetable_base[sinelookuploc];

				if( inverseoctave+1 >= SINESIZEL2 )
				{
					sinelookuploc++;
					sinecheck = 1<<(inverseoctave+1-SINESIZEL2);
				}
				else
				{
					sinelookuploc += 1<<(SINESIZEL2 - inverseoctave - 1);
					sinecheck = 1;
				}

				if (inverse)
					wi = -wi;
			}
			else
			{
				// Get sub-stepping through our sine table by rotating the
				// vector through it. a = a * b where b is the amount we want
				// to rotate. We are doing a conjugate multiply here, so we
				// can store bi as a positive value instead of a negative
				// value.  Also, oddly, we actually want to step "backwards"
				// so we actually do the inverse of a conjugate, so it looks
				// like a normal operations.
				//
				// These multiplies are mulhsu, because we can do
				// (s32 * u32)>>32, so it works out to 6 assembly instructions
				//
				// I tried a bunch of different things here to make it more
				// precise, but I landed here.
				//
				// see notes in genrotations.c
				int32_t tmp;
				tmp = (((int64_t)wr * br)>>32) - (((int64_t)wi * bi)>>32);
				wi =  (((int64_t)wi * br)>>32) + (((int64_t)wr * bi)>>32);
				wr = tmp;
			}


			// Depending on behavior, choose one of two major loops.
			// We decide if we want to shrink or allow it to naturally grow.
			// For now, we do an even-odd operation, so that the amplitude
			// is approximately maintained across FFT/IFFT
			if( inverseoctave & 1 )
			{
				// Shrink odd waves.
				for( i = m; i < N; i += istep )
				{
					j = i + l;

					int32_t tmpr = fr[j];
					int32_t tmpi = fi[j];

					int32_t zr = FIX_MPY(wr,tmpr) - FIX_MPY(wi,tmpi);
					int32_t zi = FIX_MPY(wr,tmpi) + FIX_MPY(wi,tmpr);

					int32_t qr = fr[i];
					int32_t qi = fi[i];

#if FIX32_FFT_PRECISEROUNDING
					zr >>= 1;
					zi >>= 1;
#endif

					// If we aren't doing precise rounding, shift back up
					// here. You cannot just shift one or the other here.
					// They must be paired.
					qr >>= 1;
					qi >>= 1;

					fr[j] = qr - zr;
					fi[j] = qi - zi;
					fr[i] = qr + zr;
					fi[i] = qi + zi;
				}
			}
			else
			{
				// Don't shrink even waves
				for( i = m; i < N; i += istep )
				{
					j = i + l;

					int32_t tmpr = fr[j];
					int32_t tmpi = fi[j];

					// 4x load -> 4x mulh + 2x add/sub -> 2x shifts ->
					// 4x add/sub -> 4x store
					int32_t zr = FIX_MPY(wr,tmpr) - FIX_MPY(wi,tmpi);
					int32_t zi = FIX_MPY(wr,tmpi) + FIX_MPY(wi,tmpr);

					int32_t qr = fr[i];
					int32_t qi = fi[i];

					// Here's where the top/bottom loop depart.
#if FIX32_FFT_PRECISEROUNDING == 0
					zr <<= 1;
					zi <<= 1;
#endif

					fr[j] = qr - zr;
					fi[j] = qi - zi;
					fr[i] = qr + zr;
					fi[i] = qi + zi;
				}
			}
		}
	}

	return 0;
}


int fix32_fftr( int32_t f[], int m, int inverse )
{
	m--;

	int ret = 0;
	uint32_t N = 1<<(m);
	int32_t *fr = f, *fi = &f[N];

	for( int t = 0; t < 2; t++ )
	{
		if( inverse == t )
		{
			for( int i = 1; i < N; i += 2 )
			{
				FIX32FFT_SWAP( f[N+i-1], f[i] );
			}
		}
		else
		{
			ret = fix32_fft( fi, fr, m /* m-1 */, inverse );
		}
	}

	return ret;
}


void fix32_shift( int32_t * fr, int32_t * fi, int m, int shift )
{
	int N = 1<<m;
	int i;
	if( shift < 0 )
	{
		shift = -shift;
		if( fr )
		{
			for( i = 0; i < N; i++ )
				fr[i]>>=shift;
		}
		if( fi )
		{
			for( i = 0; i < N; i++ )
				fi[i]>>=shift;
		}
	}
	else
	{
		if( fr )
		{
			for( i = 0; i < N; i++ )
				fr[i]<<=shift;
		}
		if( fi )
		{
			for( i = 0; i < N; i++ )
				fi[i]<<=shift;
		}
	}
}

#endif
#endif

